// last 4 lines of the frame have parameters
// note that the pointer math is in steps of 16 bytes because unsigned short
unsigned short *fourLinePara = orgData + requestWidth * (requestHeight - 4);

// there's an offset depending on the width
// again note that the pointer math is in steps of 16 bytes because unsigned short
int amountPixels=0;
switch (requestWidth)
{
	case 384:
		amountPixels=requestWidth*(4-1);
		break;
	case 240:
		amountPixels=requestWidth*(4-3);
		break;
	case 256:
		amountPixels=requestWidth*(4-3);
		break;
	case 640:
		amountPixels=requestWidth*(4-1);
		break;
		// TODO there's more info about this in libthermometry.so
}

uint8_t *param = fourLinePara

Location  | Datatype        | Parameter
------------------------------------------------------
  0 -   2 | 16bit uint      | FPA Average, whatever that means
  2 -   4 | 16bit uint      | FPA temperature (convert to celcius is weird and depends on camera)
  4 -   6 | 16bit uint      | Max point X
  6 -   8 | 16bit uint      | Max point Y
  8 -  10 | 16bit uint      | Max temperature
 10 -  12 | 16bit uint      | Min point X
 12 -  14 | 16bit uint      | Min point Y
 14 -  16 | 16bit uint      | Min temperature
 16 -  18 | 16bit uint      | Average temperature (orgAvg elsewhere)
 18 -  24 | ???             | ??? (unused by software)
 24 -  26 | 16bit uint      | Center temperature
 26 -  28 | 16bit uint      | User point 1 temperature
 28 -  30 | 16bit uint      | User point 2 temperature
 30 -  32 | 16bit uint      | User point 3 temperature

uint8_t *param = fourLinePara + amountPixels

Location  | Datatype        | Parameter
------------------------------------------------------
  0 -   2 | 16bit uint      | ??? (cal_00 / v5 / cx) (presumeably calibration value)
  2 -   4 | 16bit uint      | Shutter temperature (times 10, in kelvin)
  4 -   6 | 16bit uint      | Core temperature (times 10, in kelvin)
  6 -  10 | float (32bit)   | ??? (cal_01 / flt_10003360) (presumeably calibration value)
 10 -  14 | float (32bit)   | ??? (cal_02 / flt_1000335C) (presumeably calibration value)
 14 -  18 | float (32bit)   | ??? (cal_03 / flt_1000339C) (presumeably calibration value)
 18 -  22 | float (32bit)   | ??? (cal_04 / flt_10003398) (presumeably calibration value)
 22 -  26 | float (32bit)   | ??? (cal_05 / flt_10003394) (presumeably calibration value)
 26 -  48 | ???             | ??? (unused by software)
 48 -  64 | 16 byte string  | Firmware version
 64 -  80 | 16 byte string  | Serial number
 80 -  95 | 16 byte string  | Product name
 95 - 254 | ???             | ??? (unused bgy software)
---User area, writeable by ABS_ZOOM command-----------
254 - 258 | float (32bit)   | Correction
258 - 262 | float (32bit)   | Reflected temperature
262 - 266 | float (32bit)   | Air temperature
266 - 270 | float (32bit)   | Humidity
270 - 274 | float (32bit)   | Emissivity
274 - 278 | 16bit uint      | Distance (NOTE i want to try and see if i can store a float there)
278 - ??? | ???             | Possibly more user area (presumeably 128 bytes of it, java reads that much)

The user values are saved by:
	setValue(UVCCamera.CTRL_ZOOM_ABS, 0x80ff);

CTRL_ZOOM_ABS is used with the following commands:
	- < 0x80 in the high byte as an adress to write the low byte in user area
	- 0x8000 to click the shutter
	- 0x8004 called on start, not sure what it does, "切换数据输出8004原始8005yuv,80ff保存"
		* 8005 sets a different mode, the camera seems to default to 0x8004
			... or the camera remembers the last mode... maybe 0x80FF saves this too?
		* Strong indications the output is YUV encoded video in 8005 mode.
	- 0x8020 to set -20 to 120C range (followed by shutter)
	- 0x8021 to set 120 to 400C range (followed by shutter)
	- 0x80FF (as before) to store user area in non-volatile storage
	- 0xEC.., 0xEE.. Set user point x, y to low bytes? "用户盲元表"
